#!/usr/bin/env python3

#Note that `&&&` in a comment by the code means that the section of code is unfinished. `Unimplemented` by a comment means it's unimplemented (but it may or may not be finished). ###### marks the beginning of a significantly different section of the code.

import glob, sys, os, subprocess, re, pickle, platform, shutil, pathlib, tempfile, getpass;

#Variables with capital letters aren't meant to change their values during execution.

PN="Ki"; #Program name, used in the documentation.
FN="ki"; #File name, used in the documentation and other areas.
VER="0.9.18"; #The current program version.

VERSION=f"""
Version {VER}
Each upload to Github constitutes a new version. I only change the version right before the upload, regardless of whatever else I change in the meantime.
This version only applies to this file (not the other files in the project).
""".strip();

ABOUT=f"""
Introduction:
{PN} is a tool to assist you in accessing files via the command-line. If you like complex/organized directory structures, but want a faster or easier way to navigate them, {PN} is for you. It was written in Python 3.x. It does not work for Python 2.x.

History:
I'm light-sensitive. I'm a programmer. I'm a writer. I made a text editor / IDE for my desktop computer, designed for writing and programming. However, my light-sensitivity increased, and I couldn't spend much time on my desktop computer anymore. So, I got a new Android tablet with a built-in screen that filters the light. It works great, but Android isn't the same as good old Xubuntu, and my text editor doesn't work on Android (because it's written in Python with Tkinter as the GUI). Android isn't really designed with productivity for programmers and writers in mind, unfortunately (especially when it comes to things like quickly switching between activities, multitasking, efficiency, speed-of-use, and file managing). So, after examining my Linux installation options, I concluded that it would be a lot of hassle to get my text editor / IDE working on my tablet. So, I decided to use Termux (a command-line Linux), and nano, and learn how to use them for my purposes.

I discovered that you can actually do a lot of multi-tasking with Termux and Nano (if you know how and get used to it), but navigating the command-line still required a whole lot of typing, and patience. Although I'm a fast typer, I didn't like having to cd into directories all the the time to do anything, nor having to type the program name, file extension, etc. The idea of {PN} came to me. I made it. It worked. I added more features. Now I can get a lot more stuff done in less time, with less likelihood of forgetting stuff before I get to my destination.

{PN} was written using nano in Termux, and after considerable development I later (about version 0.9.0) sometimes programmed my own GUI-based editor; Termux is a great environment and use-case for key (I recommend a bluetooth keyboard).

Contact/download:
My website: www.growspice.com
Also, see this: {FN}.growspice.com
Github page: https://github.com/kumoshk/{FN}
""".strip();

HELP=f"""
Definitions:
• {PN}: The name of our program.
• {FN}: The filename of {PN}. This is what you type to execute it; `.{FN}` is also the starting default file extension.
• key: Any file--with any extension--that you open with {PN}.

Introduction:
Welcome to {PN}, which is designed to make your command-line life easier. It allows you to open a file with a specific name (default) or all the files with that name (searching recursively) within a directory structure, with a program of your choice (nano being the default). For instance, if you are in `~/book/` and you type `{FN} Sam Jones` it will search `/book/` and all its subdirectories recursively for a file named `Sam Jones.{FN}`; when it finds one, it will open it with the nano text editor (without changing the current directory).

Note that you must only provide one file name per use of {PN} (and you do not need to surround it with quotes, nor escape spaces); you do not need to type `.{FN}` when using the default settings. You may do those things, however. `.{FN}` is the default file extension, but you can change it, or make it so no extension is used.

If a file does not exist, {PN} will prompt you to create it (and ask where to do so, giving you some convenient options).

{PN} saves your decisions for future uses of the program. {PN} is not currently designed to be used from a script. It is designed for use by humans.

The name {PN} (formerly key, but that was taken by Donkey) is inspired by dictionary key value pairs (or entries in an index, such as a glossary, or an actual lexicon). Because entries in such tend to have unique names, opening only one file by that name is the default.

{PN} begins each feedback entry (except for such as this help page) with a bullet, in order to make them more readable.

Combinable options:
[Note: You must include a hyphen before the flags, or else before each flag.]
• -q: reset the app settings. You will lose any configurations that you have made.
• -o: Toggle whether {PN} opens multiple files with the same name (default is false).
• -A: If used, the first word you enter after the flags will be the new default app {PN} uses to open files, or to run files if the -x flag is also provided (if you follow it with a file, it will open it in the regular fasion; e.g. `{FN} -A cat test` will open `test.{FN}`, and any subsequent keys opened, with `cat`; assuming python weren't already the default, `{FN} -Ax python test.py` will run test.py with python and set python as the default app for running files with -x).
• -a: Like -A, except it doesn't change the default app, nor does it affect -x. It just opens with the specified app this one time.
• -e: This prompts you to set the default file extension.
• -d: Set the default directory: If no base directory is set, make the current working directory the default directory. If there is at least one base directory, make the current or last-accessed base directory the default directory (in that priority order). You may only have one default directory at a time.
• -D: Toggle whether to use the default directory (default is False). This overrides everything else (and uses it as your current base directory no matter where you are).
• -b: Make the current working directory a base directory (you can have multiple base directories).
• -r: Remove the current directory (or the current base directory) from being a base directory.
• -s: Toggle whether to search for the key (file) to open from the base directory (if you are inside a base directory structure). The default is true; so, if you don't want to open keys starting from the base directory that aren't in/under the current directory you're in within that base directory, then you should set this to false.
• -c: Clear the list of base directories, or remove the current base directory from being a base directory (you will be prompted which to do).
• -n: List the base directories, and the default directory.
• -h: Print the help.
• -v: Print the version information (to save you the bother, it's version {VER}).
• -p: Prompts you for a specific file extension to open with a specific app, every time; you can also set the default extension here.
• -P: Prompts you to undo a specific customization previously made with -p or -X.
• -2: Toggle whether to open the specified extension instead of the default (this won't work for no extension). Note that if this is set, for instance, typing `{FN} test.{FN}` will open `test.{FN}` instead of `test.{FN}.{FN}` even when the default extension is `.{FN}`, but if you type `test.txt` it will open `test.txt` instead of `test.txt.{FN}` (again, when the default extension is `.{FN}`). The default setting is true.
• -4: Toggle whether when specified extensions are opened (see -2) they become the new default or not. The default setting is false.
• -x: This executes the file instead of opening it. For instance, instead of opening a .py file with nano, it may run it with python. This must be set each time you wish to use it (it doesn't toggle a saved variable).
• -X: This is like -p, except it's for the apps that are used when -x is provided. It's basically a second set of the same thing.
• -u: Use this to update {PN}. If you wish to do a system-wide update, you'll need to use `sudo python3 ki -u` or `sudo ki -u` (you don't need `sudo` on Termux).

Non-combinable options:
• --about: About {PN}, contact, etc.
• --help: Print the help (without the option of doing other stuff at the same time).
• --version: Print the version information. (FYI, it's version {VER}.)
Special options:
• Begin search query with a colon (it won't open a key): Find all the files in the directory structure (or base or default directory structure), regardless of file extension (e.g. `{FN} :my search text` is the same as `grep -rliF --include=\* my\ search\ text /base/directory/**/`, or if it's the current working directory, it's like `grep -rliF --include=\* my\ search\ text ./`).

Warnings:
• You use {PN} at your own risk. It's under development, with possible bugs, and it's a complex program that you might misuse on accident. Your use of it may result in unintentional loss of data.
• Should the program crash, note that it's possible that some data was not saved during that execution of {PN} (since the print statements occur before the saving in many instances, in order to make the code more efficient).
• Improper configuation may result in undesirable effects.
• You use this software at your own risk. It comes with no guarantees. You assume all responsibility for what happens by using it, etc.
• Flags are evaluated before the key (the file).
• Flags are not evaluated in any particular order.
Tips:
• Use `ls -R` to show the contents of a directory structure recursively.
• If you need to find the application data, it's at `~/.{FN}_kumoshk`.
""".strip();

NANORC="""set tabsize 4
set tabstospaces
set nowrap
set softwrap
set autoindent
set atblanks
set afterends
set zap
set nonewlines
set multibuffer
set speller "hunspell -x -c"
set rawsequences
bind ^H chopwordleft main
""";

######

path=os.getcwd();
execute_it=False; #If changed to True, "xapp" and "xapps" will be used in place of "app" and "apps".
settings={}; #One dictionary for all the settings.
settings["extension"]=f".{FN}"; #Unimplemented
extension=None; #This is to make it global down below, so the getApp() method can use it.
settings["scriptExtension"]=".ks"; #Unimplemented; Files with this extension, rather than just being opened, can perform various actions (such as specify a list of files to open, open random files, according to a set of likelihoods, etc.).
settings["firstRun"]=True;
settings["app"]="nano"; #This is the default app for opening files; 'apps' below overrides this, however.
settings["xapp"]="cat"; #This is the default app to execute files with when they're not already set to be executable.
settings["apps"]={}; #Default apps to open the various file extensions. Keys are file extensions and values are the apps to open them.
settings["xapps"]={}; #xapps is to xapp as apps is to app
settings["xapps"][".py"]="python3";
settings["xapps"][".lua"]="lua5.4";
settings["xapps"][".rb"]="ruby";
settings["xapps"][".pl"]="perl";
settings["xapps"][".ly"]="lilypond";
soundApps="8svx aif aifc aiff aiffc al amb au avr caf cdda cdr cvs cvsd cvu dat dvms f32 f4 f64 f8 fap flac fssd gsm gsrt hcom htk ima ircam la lpc lpc10 lu mat mat4 mat5 maud mp2 mp3 nist ogg opus paf prc pvf raw s1 s16 s2 s24 s3 s32 s4 s8 sb sd2 sds sf sl sln smp snd sndfile sndr sndt sou sox sph sw txw u1 u16 u2 u24 u3 u32 u4 u8 ub ul uw vms voc vorbis vox w64 wav wavpcm wve xa xi m3u pls".split(" ");
for x in soundApps:
    settings["xapps"]["."+x]="play";
settings["lastKeyDir"]=None; #Directory of the last key opened.
settings["defaultDir"]=None; #This is a saved directory for frequent use, which can be changed. You can use it even when you're not in it.
settings["useDefault"]=False; #If this is true then when you're not in a base directory, it will act as if you are in the default directory structure no matter where you are.
settings["baseDirs"]=set(); #This is a set of directories. If you're within these when you use Ki, it will always search from it even when in its subdirectories. You can't set both a directory and one of its subdirectories to be in baseDirs.
settings["baseDir"]=None; #This is the current base directory (of if there is no current one, it is the last base directory used).
settings["searchBaseDir"]=True; #Whether or not to search for keys from the base dir when in its subdirectories (and so on recursively).
settings["openAll"]=False; #Whether or not to open all files found or just one.
settings["setOpenDefault"]=False; #Whether opening a file with a specific extension sets that extension to be the default.
settings["openSpecifiedExt"]=True; #Whether you can open extensions that aren't the default just by typing them in (this won't work for blank extensions).
backup=settings.copy();
save_it=False; #If set to True, settings will be saved (pickled). Calling saveSettings() sets it back to False.
oneTimeApp=None;

######

#Make sure the user settings folder exists.
settingsPath=None;
settingsPath=os.path.join(os.path.expanduser("~"), f".{FN}_kumoshk");
if not os.path.isdir(settingsPath):
    os.makedirs(settingsPath);

#Load the settings, if they've been saved.
settingsDictPath=os.path.join(settingsPath, "settings_dict.pkl");
if os.path.exists(settingsDictPath):
    with open(settingsDictPath, "rb") as FILE:
        settings=pickle.load(FILE);

def saveSettings():
    #Use this wherever you want to save the settings.
    global save_it, settings;
    save_it=False; #To make sure we don't do redundant saves.
    with open(settingsDictPath, "wb") as FILE:
            pickle.dump(settings, FILE, -1);

baseDir=None;
for x in settings["baseDirs"]:
    if path.startswith(x+os.sep) or x==path:
        baseDir=x;
        if settings["baseDir"]!=baseDir:
            settings["baseDir"]=baseDir;
            save_it=True;
        break;

######

def ask(question, desired=None, pw=False):
    if question.endswith(" ")==False:
        question=question+" ";
    if pw==False:
        askFunc=input;
    else:
        askFunc=getpass.getpass;
    response=None;
    if desired==None:
        return askFunc(question);
    else:
        while response not in desired:
            response=askFunc(question);
        return response;

def askyn(question, pw=False):
    return ask(question=question, desired={"yes", "y", "no", "n"}, pw=pw);

def askdir(question, pw=False, ask_file=False, must_exist=True, must_perm=True, default_dir=None, default_dir2=None, default_dir3=None):
    print("• Enter * to cancel.");
    if default_dir!=None:
        print(f"• Enter ** to use the default: `{default_dir}`.");
    if default_dir2!=None:
        print(f"• Enter *** to use the program directory: `{default_dir2}`");
    if default_dir3!=None:
        print(f"• Enter **** to use the home bin directory: `{default_dir3}`");
    if question.endswith(" ")!=True:
        question=question+" ";
    if pw==False:
        askFunc=input;
    else:
        askFunc=getpass.getpass;
    response=None;
    while 1:
        response=askFunc(question);
        if response=="" or response=="." or response=="./":
            response=os.path.expanduser(path);
        if response=="*":
            return None;
        if response=="**" and default_dir!=None:
            response=default_dir;
        if response=="***" and default_dir2!=None:
            response=default_dir2;
        if response=="****" and default_dir3!=None:
            response=default_dir3;
        response=os.path.expanduser(response);
        response=os.path.abspath(response);
        if os.path.exists(response) and must_exist==True:
            if os.path.isdir(response):
                if ask_file==False:
                    if must_perm==True:
                        if perm(response):
                            return response;
                        else:
                            print(f"• You do not have permission to write in `{response}`. Try another path.");
                    else:
                        return response;
                else:
                    print(f"• The path, `{response}`, is not a file. Please try another path.");
            else:
                if ask_file==False:
                    print(f"• The path, `{response}`, is not a directory. Please try another path.");
                else:
                    return response;
        elif must_exist==False:
            if ask_file==False:
                if must_perm==True:
                    if perm(response):
                        return response;
                    else:
                        print(f"• You do not have permission to write in `{response}`. Please try another path.");
                else:
                    return response;
            else:
                return response;
        else: #must_exist==True and the file exist:
            createyn=askyn(f"The path, `{response}` does not exist. Would you like to create it?");
            if createyn in {"yes", "y"}:
                os.makedirs(response);
                if not os.path.isdir(response):
                    print(f"• `{response}` not created. You likely don't have permission. Try another path.");
                else:
                    print(f"• `{response}` created.");
                    return response;
            else:
                print(f"• Please try another path.");
    return response;

def askfile(question, pw=False, ask_dir=False):
    #Permissions are not tested for files.
    return askdir(question=question, pw=pw, ask_file=True);

######

#First run stuff
if settings["firstRun"]==True:
    settings["firstRun"]=False;
    save_it=True;
    nanorc_path="~/.nanorc";
    nanorc_path=os.path.expanduser(nanorc_path);
    if os.path.exists(nanorc_path)==False:
        yn=askyn(f"""Would you like to install some convenient nano settings in `{os.path.join(os.path.expanduser("~/"), ".nanorc")}`? These settings don't work on some versions of nano before 5.8. If it gives you errors when you run nano, either update nano, or delete the `.nanorc` file.""");
        if yn in {"yes", "y"}:
            print("For tips on how to use nano, see\n<https://www.growspice.com/A-desktop-user-s-guide-to-Nano-a-command-line-text-editor-td3471.html>.");
            with open(nanorc_path, "w") as FILE:
                FILE.write(NANORC);
            print("`.nanorc settings written.`");
        else:
            print("`.nanorc` settings not written.");

######

def user_group(p):
    stat=os.stat(p);
    return {"user":stat.st_uid, "group":stat.st_gid};
def getPerm(p): #Gets the important part of the permission mask.
    return oct(os.stat(p).st_mode)[-3:];
def perm(dp): #Test to see if you have permission to write in the directory (or else the directory of a file).
    global path;
    dp=os.path.dirname(dp);
    if dp=="":
        dp=path;
    #print(os.access(dp, os.W_OK), os.access(dp, os.X_OK));
    #print(getPerm(dp));
    return os.access(dp, os.W_OK | os.X_OK);
def setPerm(p, permissions): #Sets the permissions (e.g. 755). p is the file or directory path (it's permissions will be set). This function requires sudo privileges.
    subprocess.run(["chmod", "0"+permissions, p]);
def is_exec(fp):
    #Tells if the file is executable or not.
    return os.access(fp, os.X_OK) #test to see if the file is executable
def set_exec(fp, set_it=True): #Make the file executable or not executable
    dn=os.path.dirname(fp);
    isdir=os.path.isdir(dn);
    if perm(dn)==True and isdir==True:
        if set_it==True:
            subprocess.run(["chmod", "+x", fp]); #make the file executable
        else:
            subprocess.run(["chmod", "-x", fp]); #make the file not executable
    else:
        if isdir==True:
            raise PermissionError("You don't have permission to change the executable status of `"+os.path.basename(fp)+"`.");
        else:
            raise FileNotFoundError("`"+fp+"` does not exist.");

def programPath(): #Get the file path of Ki.
    #pp=os.path.join(sys.path[0], sys.argv[0]);
    pp=os.path.realpath(__file__);
    if os.path.isfile(pp):
        return pp;
        #pp=str(pathlib.Path(pp).resolve().absolute()); #If the path is such as /usr/bin/ki, then it's a symlink that points somewhere else, and we need to get where it points.
    else:
        return None;

def directoryPath(): #Get the directory path of Ki.
    return os.path.dirname(programPath());

multipleFiles=None;

chars="\\ !\"'#$&()*,;<>?[]{}^`|";
def escapePath(p):
    global chars;
    for x in chars:
        p=p.strip().replace(x, "\\"+x);
    return p;

def unescapePath(p):
    global chars;
    for x in chars:
        p=p.strip().replace("\\"+x, x);
    return p;

def eglob(p1, p2, recursive=False): #escaping variant of glob
    escapedPath=glob.escape(p1)+"/**/"+glob.escape(p2).replace("[*]", "*"); #&&&Research any others you might not want to be escaped (the asterisk allows you to do wildcard searches for files: e.g. ki myPartial*
    to_return=glob.glob(escapedPath, recursive=recursive);
    if settings["openAll"]==False:
        i=0;
        while i<len(to_return):
            if os.path.isdir(to_return[i])==False:
                return [to_return[i]];
            if i==len(to_return)-1:
                return [];
            i+=1;
    else:
        for x in to_return.copy():
            if os.path.isdir(x):
                to_return.remove(x);
    return to_return;

def getApp():
    global extension, oneTimeApp;
    if oneTimeApp!=None:
        return oneTimeApp;
    elif execute_it==True:
        if extension in settings["xapps"]:
            return settings["xapps"][extension];
        else:
            return settings["xapp"];
    else:
        if extension in settings["apps"]:
            return settings["apps"][extension];
        else:
            return settings["app"];

def addCurrentBaseDir(): #Make the current working directory a base directory.
    global settings, path, save_it;
    for x in settings["baseDirs"]:
        if path==x:
            print("• The current working directory is already a base directory. It cannot be added.");
            return False;
        elif path.startswith(x+os.sep):
            print("• The current working directory is already within the directory structure of a base directory. It cannot be added. Here is the base directory:\n"+x);
            return False;
        elif x==path:
            print("• The current working directory is already a base directory. It cannot be added.");
            return False;
        elif x.startswith(path+os.sep):
            print("• The current working directory has a base directory within its recursive subdirectories. It cannot be added. Here is the base directory:\n"+x);
            return False;
    settings["baseDirs"].add(path); #path is a global variable.
    print("• Adding the current working directory to your list of base directories. Here is the new list of all your base directories:\n"+"\n".join(settings["baseDirs"])+"\n");
    save_it=True;
    return True;

def updateProgram(): #Update the program
    global path;
    with tempfile.TemporaryDirectory() as DIR:
        print("• Downloading the update to a temporary directory.");
        tempDownload=os.path.join(DIR, FN);
        subprocess.run(["wget", "https://raw.githubusercontent.com/kumoshk/"+PN.lower().replace(" ", "-")+f"/main/{FN}", "-P", DIR]);
        if os.path.exists(tempDownload)==False:
            print(f"• Downloading the update failed. {PN} not updated.");
        else:
            proDir=directoryPath();
            pp=programPath();
            if pp!=None:
                if not perm(pp):
                    pp=None
            if proDir!=None:
                if not perm(proDir):
                    proDir=None;
            yn=None;
            updatePath=None;
            def updateLocal():
                recommendedPath="/opt/bin";
                if path.startswith("/data/data/com.termux/files/"):
                    recommendedPath="/data/data/com.termux/files/usr/opt/bin";
                upDir=askdir(f"• Please enter a path in which to install {PN}:", default_dir=recommendedPath, default_dir2=os.path.dirname(pp), default_dir3="~/bin");
                if upDir==None:
                    print("• Update canceled");
                    return False;
                updatePath=os.path.join(os.path.expanduser(upDir), FN);
                if os.path.exists(updatePath):
                    if os.path.isdir(updatePath):
                        print(f"• A directory exists in that location. {PN} not updated.");
                        return False;
                    else:
                        overwrite=askyn(f"• `{updatePath}` already exists. Would you like to overwrite? ");
                        if overwrite in {"yes", "y"}:
                            return True, updatePath;
                        else:
                            print(f"• File not overwritten. {PN} not updated.");
                            return False;
                else:
                    #updatePath doesn't exist; make it.
                    return True, updatePath;
                #End updateLocal()
            if proDir!=None and pp!=None:
                ulresult=updateLocal();
                if ulresult==False:
                    return False;
                else:
                    updatePath=ulresult[1];
                print("We have permission.");
                if os.path.exists(updatePath):
                    os.remove(updatePath);
                #print(tempDownload, updatePath);
                shutil.copyfile(tempDownload, updatePath);
                fileUserGroup=None;
                if os.path.exists(updatePath)==True:
                    fileUserGroup=user_group(updatePath);
                    if fileUserGroup["user"]==0 or fileUserGroup["group"]==0: #0 is root
                        setPerm(updatePath, getPerm(os.path.dirname(updatePath)));
                        permDict=user_group(os.path.dirname(updatePath));
                        shutil.chown(updatePath, user=permDict["user"], group=permDict["group"]);
                    else:
                        set_exec(updatePath);
                print(f"• {PN} successfully updated.");
                inPath=False;
                for x in sys.path:
                    x=os.path.expanduser(x);
                    x=os.path.abspath(x);
                    if x==updatePath:
                        inPath=True;
                        break;
                    elif os.path.isfile(os.path.join(x, FN))==True:
                        inPath=True;
                        break;
                putInPath=None;
                putInPath=askyn(f"• Would you like to put {PN} in your path? ");
                if putInPath in {"y", "yes"}:
                    if os.path.exists(updatePath)==True and "SUDO_UID" in os.environ.keys():
                        #Add to path for all users
                        if inPath==True:
                            yn=None;
                            yn=askyn(f"• There are already one or more programs called `{FN}` in your path. Remove it/them and update? ");
                            if yn in {"yes", "y"}:
                                subprocess.run(["update-alternatives", "--remove-all", FN]);
                        subprocess.run(["update-alternatives", "--install", f"/usr/bin/{FN}", FN, updatePath, "0"]);
                    else:
                        #Add to path for current user
                        bashrc=os.path.expanduser("~/.bashrc");
                        FN2path=f"export PATH=$PATH:{os.path.expanduser(updatePath)}";
                        bin2path=f"export PATH=$PATH:{os.path.expanduser('~/bin')}";
                        opt2path=f"export PATH=$PATH:{os.path.expanduser('/opt/bin')}";
                        if path.startswith("/data/data/com.termux/files/"):
                            opt2path=f"export PATH=$PATH:/data/data/com.termux/files/usr/opt/bin";
                        if os.path.isdir(bashrc):
                            print(f"• Error. `{bashrc} is a directory when it should be a file.` Not added to path.");
                            return None;
                        elif os.path.isfile(bashrc):
                            #Appending it to ~/.bashrc
                            with open(bashrc, "r") as FILE:
                                bashrcContents=FILE.read();
                                bashrcSplit=bashrcContents.split("\n");
                                if opt2path not in bashrcSplit:
                                    with open(bashrc, "a") as FILE2:
                                        FILE2.write(f"\n{opt2path}");
                                if bin2path not in bashrcSplit:
                                    with open(bashrc, "a") as FILE2:
                                        FILE2.write(f"\n{bin2path}");
                                if FN2path not in bashrcSplit and os.path.dirname(FN2path) not in bashrcSplit:
                                    with open(bashrc, "a") as FILE2:
                                        FILE2.write(f"\n{FN2path}");
                            subprocess.run(f"bash {bashrc}", shell=True);
                            print(f"Restarted `{bashrc}`.");
                        else:
                            #Creating ~/.bashrc and writing it to the path.
                            with open(bashrc, "w") as FILE:
                                if os.path.dirname(FN2path) not in {bin2path, opt2path}:
                                    FILE.write(f"{bin2path}\n{opt2path}\n{FN2path}");
                                else:
                                    #print(os.path.dirname(FN2path), {bin2path, opt2path});
                                    FILE.write(f"{bin2path}\n{opt2path}");
                            subprocess.run(f"bash {bashrc}", shell=True);
                            print(f"Restarted `{bashrc}`.");
                else:
                    print(f"• {PN} was not put in the path (but if it was already in the path before the update, it should still be there).");
                    return None;

######

if __name__=="__main__":
    if len(sys.argv)>=2:
        args=sys.argv[1:];
        pre=" ".join(args).strip(); #string args to test for flags and such before doing any manipulations.
        if pre.startswith("-")==True and pre.startswith("--")==False:
            flags=pre.replace(" -", "");
            flagSplit=flags.split(" ");
            args=flagSplit[1:];
            flags=flagSplit[0];
            if "q" in flags: #Reset app data
                yn=askyn(f"• Are you sure you want to reset {PN}'s application data? (y/n) ");
                if yn in {"y", "yes"}:
                    settings=backup.copy();
                    baseDir=None;
                    save_it=True;
                    print(f"• {PN}'s application data has been reset.");
                else:
                    print(f"• {PN}'s application data has not been reset.");
            if "o" in flags: #Toggle whetehr to open all files with the name at once (instead of just one). Default is False.
                settings["openAll"]=not settings["openAll"];
                print("• Open all files at once set to "+str(settings["openAll"])+".");
                save_it=True
            if "A" in flags: #-p This means the next non-flag group of characters is the new default app to use instead of nano, or whatever.
                if "x" in flags:
                    settings["xapp"]=args[0];
                    print("• Files will now be run with "+settings["xapp"]+" by default.\n");
                else:
                    settings["app"]=args[0];
                    print("• Files will now be opened with "+settings["app"]+" by default.\n");
                args=args[1:];
                save_it=True;
            if "a" in flags: #Like -A without changing the default app. No point using it with -x, either.
                oneTimeApp=args[0]; #&&&
                print("• Your file will open with "+oneTimeApp+", this time.\n");
                args=args[1:];
            if "e" in flags: #Set the default extension.
                ext_set=input("Please enter a file extension to be the default (blank for no file extension; `.` for cancel; current default=`"+settings["extension"]+"`): ");
                if ext_set!=None:
                    if ext_set==".":
                        print("• The default file extension has not been changed.");
                    elif ext_set=="":
                        settings["extension"]=ext_set;
                        print("• The default file extension is now no extension.\n");
                        save_it=True;
                    else:
                        if ext_set[0]!=".":
                            ext_set="."+ext_set;
                        settings["extension"]=ext_set;
                        print("• The default file extension is now `"+settings["extension"]+"`.\n");
                        save_it=True;
                else:
                    print("• The default file extension has not been changed.");
            if "d" in flags: #Make the current or last-accessed base directory the default directory, or if there is none, make the current working directory the default directory (and a base directory).
                if settings["baseDir"]==None:
                    yn=askyn("• No base directories exist. Would you like to make the current working directory a base directory (and the default directory)? (y/n) ");
                    if yn in {"y", "yes"}:
                        addCurrentBaseDir();
                        #settings["baseDirs"].add(path);
                        settings["defaultDir"]=path;
                        baseDir=path;
                        settings["baseDir"]=path;
                        print("• The current working directory is now a base directory and the default directory.");
                        save_it=True;
                    else:
                        print("• New default directory not set.");
                else:
                    if baseDir==None:
                        settings["defaultDir"]=path;
                        itWorked=addCurrentBaseDir();
                        #settings["baseDirs"].add(path);
                        if itWorked==True:
                            print("• The current working directory is now set to be the default directory.");
                        else:
                            print("• The current working directory has not been set to be the default directory.");
                    else:
                        settings["defaultDir"]=settings["baseDir"];
                        if settings["defaultDir"]==baseDir:
                            print("• The current base directory is now set to be the default directory:\n"+settings["defaultDir"]);
                        else:
                            print("• The last-accessed base directory is now set to be the default directory:\n"+settings["defaultDir"]);
                    save_it=True;
            if "D" in flags: #Toggle whether to use the default directory when you aren't in a base directory.
                settings["useDefault"]=not settings["useDefault"];
                print("• Use default directory (when not in a base directory structure) set to "+str(settings["useDefault"])+".");
                save_it=True;
            if "b" in flags: #Add the current working directory (not that of the key opened_ to baseDirs.
                addCurrentBaseDir();
            if "r" in flags: #Remove the current directory or current base directory from being a base directory.
                if baseDir==None:
                    print("• You are not in a base directory structure and so cannot remove it from being a base directory (because it isn't one). No base directory removed from being a base directory.");
                else:
                    yn=askyn("• Are you sure you want to remove the current base directory from being a base directory? FYI, if so, if it's the default directory, it will no longer be the default. (y/n) ");
                    if yn in {"y", "yes"}:
                        settings["baseDirs"].remove(baseDir);
                        if settings["baseDir"]==baseDir:
                            settings["baseDir"]=None;
                        if settings["defaultDir"]==baseDir:
                            settings["defaultDir"]=None;
                            print("• The default directory is no longer set.");
                        save_it=True;
                        print("• The current base directory has been removed from being a base directory:\n"+baseDir);
                        baseDir=None;
                    else:
                        print("• The current base directory is unchanged (still a base directory).");
            if "s" in flags: #Toggle whether to search for the key to open from the base directory (default is True).
                settings["searchBaseDir"]=not settings["searchBaseDir"];
                print("• Searching for keys from the base directory set to "+str(settings["searchBaseDir"])+".");
                save_it=True;
            if "c" in flags: #Clear the list of base directories, or remove the current base directory from being a base directory.
                if len(settings["baseDirs"])>0:
                    yn=ask("• Are you sure you want to clear the following base directories?\n"+"\n".join(settings["baseDirs"])+"\n(y/n; press c to remove only the current base directory.) ", desired={"yes", "y", "no", "n", "c"});
                    if yn in {"y", "yes"}:
                        settings["baseDirs"].clear();
                        save_it=True;
                        print("• Base directories cleared.");
                        baseDir=None;
                        if settings["defaultDir"]!=None:
                            settings["defaultDir"]=None;
                            print("• The default directory has been removed.");
                    elif yn=="c":
                        if baseDir==None:
                            print("• You are not in a base directory. It cannot be removed.");
                        else:
                            settings["baseDirs"].remove(baseDir);
                            save_it=True;
                            print("• The following directory is no longer a base directory:\n"+baseDir);
                            baseDir=None;
                    else:
                        print("• Base directories not cleared.");
                else:
                    print("• You don't have any base directories set to clear.");
            if "n" in flags: #List the base directories and the default directory.
                print("• Default directory:\n"+str(settings["defaultDir"]));
                if len(settings["baseDirs"])>0:
                    print("• Base directories:\n"+"\n".join(settings["baseDirs"]));
                else:
                    print("• Base directories:\nNone");
            if "h" in flags: #Print the help string.
                print("\n\n"+HELP+"\n\n");
            if "v" in flags: #Print the version string.
                print("\n\n"+VERSION+"\n\n");
            if "p" in flags: #Set a specific extension to open with a specific app.
                whichExtension=None;
                whichApp=None;
                print("• Here you can specify which app will correspond to which file extension. (This overrides the default program.)");
                whichExtension=input("• Please enter a file extension (keep blank for no file extension; type * to set the default app for all unassigned extensions): ");
                if whichExtension!=None:
                    whichApp=input("• Please enter the name of an app to open it: ");
                if whichApp!=None:
                    if whichApp.strip()!="":
                        if whichExtension=="*":
                            settings["app"]=whichApp;
                            save_it=True;
                            print("• All unhandled extensions will now be opened with `"+whichApp+"`.")
                        else:
                            whichExtension=re.sub(r"^\.*(\w+)", r".\1", whichExtension).strip();
                            settings["apps"][whichExtension]=whichApp;
                            save_it=True;
                            print("• The extension `"+whichExtension+"` is now handled by `"+whichApp+"`");
                    else:
                        print("• Your app name must be more than whitespace.");
                else:
                    print("• Default app for file extension unchanged.");
            if "P" in flags: #Undo an action performed with -p.
                whichapps=ask("• Do you wish to reset regular apps or -x apps? (r/x) ", desired={"r", "x"});
                if whichapps not in {"r","x"}:
                    print("• No opening/running apps reset.");
                else:
                    if whichapps=="r":
                        whichapps=["app", "apps"];
                    else:
                        whichapps=["xapp","xapps"];
                    removeEH=input("• Please enter the extension you wish to reset (press * to reset the default extension): ");
                    if removeEH!=None:
                        if removeEH=="*":
                            settings[whichapps[0]]=backup[whichapps[0]];
                            save_it=True;
                            print("• The default app has been reset to `"+settings[whichapps[0]]+"`.");
                        else:
                            removeEH=re.sub(r"^\.*(\w+)", r".\1", removeEH).strip();
                            if removeEH in settings[whichapps[1]]:
                                try:
                                    settings[whichapps[1]][removeEH]=backup[whichapps[1]][removeEH];
                                    print("• Extension `"+removeEH+"` reset to `"+settings[whichapps[1]][removeEH]+"`.");
                                except KeyError:
                                    del settings[whichapps[1]][removeEH];
                                    print("• Extension `"+removeEH+"` reset to the default, `"+settings[whichapps[0]]+"`.");
                                save_it=True;
                            else:
                                print("• That file extension has not been set (so, it cannot be reset).");
                    else:
                        print("• No changes have been made to which apps open which extensions.");
            if "2" in flags: #Toggle whether to open the specified extension if one is specified (instead of the default), and whether to set that specified extension as the default.
                settings["openSpecifiedExt"]=not settings["openSpecifiedExt"];
                save_it=True;
                print("• Open specified extension set to "+str(settings["openSpecifiedExt"])+".");
            if "4" in flags: #Toggle non-default extension specified as the default.
                settings["setOpenDefault"]=not settings["setOpenDefault"];
                save_it=True;
                print("• The setting whether to make a specified extension the default has been set to "+str(settings["setOpenDefault"])+".");
            if "x" in flags: #Toggle the option to execute a file instead of opening it.
                execute_it=True;
                print("• The file will be executed instead of opened, where applicable, this time.");
            if "X" in flags:
                whichExtension=None;
                whichApp=None;
                print("• Here you can specify which app will correspond to which file extension when using the -x flag. (Settings for specific extensions override the default.)");
                whichExtension=input("• Please enter a file extension (keep blank for no file extension; type * to set the default app for all unassigned extensions): ");
                if whichExtension!=None:
                    whichApp=input("• Please enter the name of an app to open it: ");
                if whichApp!=None:
                    if whichApp.strip()!="":
                        if whichExtension=="*":
                            settings["xapp"]=whichApp;
                            save_it=True;
                            print("• All unhandled extensions will now be run with `"+whichApp+"` when the -x flag is given.");
                        else:
                            whichExtension=re.sub(r"^\.*(\w+)", r".\1", whichExtension).strip();
                            settings["xapps"][whichExtension]=whichApp;
                            save_it=True;
                            print("• The extension `"+whichExtension+"` is now handled by `"+whichApp+"`");
                    else:
                        print("• Your app name must be more than whitespace.");
                else:
                    print("• Default app for file extension unchanged.");
            if "u" in flags: #Prompt to install Ki to your path
                updateProgram();
        elif pre.startswith("--")==True:
            if pre=="--help":
                args=[]; #Clear the args so it won't do anything else.
                print(HELP);
            elif pre=="--version":
                args=[]; #Clear the args so it won't do anything else.
                print(VERSION);
            elif pre=="--about":
                args=[]; #Clear the args so it won't do anything else.
                print(ABOUT);
            elif pre=="--f": #&&&Open multiple filepaths (files with different names) instead of just one name; requires escaped spaces (no unescaped qutoes to handle spaces).
                multipleFiles=re.split(r"(?<!\\) ", args);
        if len(args)!=0 and args[0].startswith(":")==True:
            args=" ".join(args).strip();
            args=args[1:];
            #args=re.sub(r"\\* +", r"\\ ", args);
            args=escapePath(args);
            if baseDir!=None and settings["searchBaseDir"]==True:
                #rdir=re.sub(r"\\* +", r"\\ ", baseDir);
                rdir=escapePath(baseDir);
                subprocess.run("grep -rliF --include=\\* "+args+" "+rdir+"/**/", shell=True);
            elif settings["defaultDir"]!=None and settings["useDefault"]==True:
                rfile=os.path.join(settings["defaultDir"], args);
                #rdir=re.sub(r"\\* +", r"\\ ", settings["defaultDir"]);
                rdir=escapePath(settings["defaultDir"]);
                subprocess.run("grep -rliF --include=\\* "+args+" "+rdir+"/**/", shell=True);
            else:
                subprocess.run("grep -rliF --include=\\* "+args+" ./", shell=True);    
        elif len(args)!=0:
            ######
            extension=settings["extension"]; #We need to use this in case we don't save to save it.
            if "." in args[-1] and settings["openSpecifiedExt"]==True: #If an extension is specified, make it the new default extension (it goes from the final period to the end of the filename).
                extension="."+args[-1].split(".")[-1];
                if extension!=settings["extension"] and settings["setOpenDefault"]==True:
                    settings["extension"]=extension;
                    print("• Default extension changed to `"+settings["extension"]+"`.");
                    #saveSettings();
                    save_it=True;
            if len(args)>1:
                args=" ".join(args);
                args=args.strip();
                if not args.endswith(extension):
                    args=args+extension;
                elif settings["openSpecifiedExt"]==False: #Add the extension even if you specify it.
                    args=args+extension;
                if "\\" in args: #&&& Make it so it does args=unescapePath(args) if and only all the characters that need escaping are escaped (make a method that checks to see if they're escaped).
                    args=args.replace("\\", "");
            else:
                args=args[0];
                args=os.path.basename(args);
                if not args.endswith(extension):
                    args=args+extension;
                elif settings["openSpecifiedExt"]==False: #Add the extension even if you specify it.
                    args=args+extension;

            g=None;
            if settings["searchBaseDir"]==True and baseDir!=None:
                if settings["useDefault"]==True and settings["defaultDir"]!=None:
                    g=eglob(settings["defaultDir"], args, recursive=True);
                else:
                    g=eglob(baseDir, args, recursive=True);
            else:
                if settings["searchBaseDir"]==True and settings["useDefault"]==False:
                    print("• There is no base directory here; using the current working directory.");
                    g=eglob(path, args, recursive=True);
                elif settings["searchBaseDir"]==True and settings["useDefault"]==True and settings["defaultDir"]!=None:
                    print("• Using the default directory:\n"+settings["defaultDir"]);
                    g=eglob(settings["defaultDir"], args, recursive=True);
                elif settings["useDefault"]==True:
                    if settings["defaultDir"]!=None:
                        g=eglob(settings["defaultDir"], args, recursive=True);
                    else:
                        print("• The default directory is not set. (Acting as if it is disabled.)");
                        if baseDir==None:
                            print("• There is no base directory here; using the current working directory.");
                        g=eglob(path, args, recursive=True);
                else:
                    g=eglob(path, args, recursive=True);
            try:
                allFound=[];
                firstFile=True;
                for f in g:
                    dn=os.path.dirname(f);
                    bn=os.path.basename(f);
                    f=dn+os.sep+bn;
                    #f=re.sub(r"\\* ", r"\\ ", f);
                    #f=escapePath(f);
                    allFound.append(f);
                    if firstFile==True:
                        if settings["lastKeyDir"]!=dn:
                            settings["lastKeyDir"]=dn;
                            print("• Last key directory set to `"+settings["lastKeyDir"]+"`.");
                            #saveSettings();
                            save_it=True;
                        firstFile=False;
                if settings["openAll"]==False:
                    subprocess.run([getApp(), allFound[0]]);
                else:
                    subprocess.run([getApp()]+allFound);
            except IndexError:
                ######
                yn=None;
                def chunk():
                    global settings, path;
                    if settings["defaultDir"]==None:
                        return False;
                    else:
                        #return settings["defaultDir"].startswith(path+os.sep);
                        return path.startswith(settings["defaultDir"]+os.sep);
                if settings["useDefault"]==True and (chunk() or settings["defaultDir"]==path):
                    yn=ask("• "+args+" does not exist.\n• Do you wish to create and open it (n = no; blank = no; y = current working directory; b = base directory; k = directory of the last key opened?) ", desired={"n", "no", "", "y", "yes", "b", "k"});
                elif settings["useDefault"]==True and settings["defaultDir"]!=None:
                    yn=ask("• "+args+" does not exist.\n• Do you wish to create and open it (n = no; blank = no; b = base directory; k = directory of the last key opened?) ", desired={"no", "", "n", "b", "k"});
                    if yn in {"y", "yes"}:
                        yn="n";
                else:
                    yn=ask("• "+args+" does not exist.\n• Do you wish to create and open it (n = no; blank = no; y = current working directory; b = base directory; k = directory of the last key opened?) ", desired={"y", "yes", "n", "no", "", "b", "k"});
                if yn in {"y", "yes"}:
                    if settings["lastKeyDir"]!=path:
                        settings["lastKeyDir"]=path;
                        print("• Last key directory set to `"+settings["lastKeyDir"]+"`.");
                        #saveSettings();
                        save_it=True;
                    if perm(args)==True:
                        subprocess.run(["touch", args]);
                        if os.path.isdir(args)==True:
                            print("• Sorry, a directory named `"+args+"` already exists. Key not created.");
                        else:
                            print("• "+args+" created.");
                            subprocess.run([getApp(), args]);
                            if os.path.isdir(args):
                                print("ERROR: `"+args+"` is a directory???");
                            else:
                                pass;
                                #print("HERE"); #Working normally.
                    else:
                        print("• You don't have permission to create `"+args+"` in `"+path+"`.");
                elif yn=="b":
                    if settings["useDefault"]==True and settings["defaultDir"]!=None:

                        file=os.path.join(settings["defaultDir"], os.path.basename(args));
                        if settings["lastKeyDir"]!=settings["defaultDir"]:
                            settings["lastKeyDir"]=settings["defaultDir"];
                            print("• Last key directory set to `"+settings["lastKeyDir"]+"`.");
                            save_it=True;
                        if perm(file)==True:
                            subprocess.run(["touch", file]);
                            print("• "+args+" created in the default directory:\n"+file);
                            subprocess.run([getApp(), file]);
                        else:
                            print("• You do not have permission to create `"+file+"`.");
                    else:
                        if settings["useDefault"]==True and settings["defaultDir"]==None:
                            print("• No default directory has been set. Acting as if the default directory is disabled.");
                        if baseDir==None:
                            print("• You are not within a base directory structure.");
                            if settings["baseDir"]==None:
                                print("• "+args+" not created.");
                            else:
                                yn2=askyn("• Would you like to create it within the last-accessed base directory? (y/n) ");
                                if yn2 in {"y", "yes"}:
                                    file=os.path.join(settings["baseDir"], os.path.basename(args));
                                    if settings["lastKeyDir"]!=settings["baseDir"]:
                                        settings["lastKeyDir"]=settings["baseDir"];
                                        print("• Last key directory set to `"+settings["lastKeyDir"]+"`.");
                                        save_it=True;
                                    if perm(file)==True:
                                        subprocess.run(["touch", file]);
                                        print("• "+args+" created in the last-accessed base directory:\n"+file);
                                        subprocess.run([getApp(), file]);
                                    else:
                                        print("• You do not have permission to create `"+file+"`.");
                                else:
                                    print("• "+args+" not created.");
                        else:
                            file=os.path.join(baseDir, os.path.basename(args));
                            if settings["lastKeyDir"]!=baseDir:
                                settings["lastKeyDir"]=baseDir;
                                print("• Last key directory set to `"+settings["lastKeyDir"]+"`.");
                                save_it=True;
                            if perm(file)==True:
                                subprocess.run(["touch", file]);
                                print("• "+args+" created in the base directory:\n"+file);
                                subprocess.run([getApp(), file]);
                            else:
                                print("• You do not have permission to create `"+file+"`.");
                elif yn=="k":
                    if settings["useDefault"]==True and settings["defaultDir"]!=None and settings["lastKeyDir"].startswith(settings["defaultDir"]+os.sep)==False:
                        print("• The last key directory is not within the default directory structure. No file created.");
                    else:
                        if settings["useDefault"]==True and settings["defaultDir"]==None:
                            print("• The default directory is not set. Acting as if the default directory is disabled.");
                        file=os.path.join(settings["lastKeyDir"], os.path.basename(args));
                        if perm(file)==True:
                            subprocess.run(["touch", file]);
                            print("• "+args+" created in the last key directory:\n"+file);
                            subprocess.run([getApp(), file]);
                        else:
                            print("• You do not have permission to create `"+file+"`.");
                else:
                    print("• "+args+" not created.");
    if save_it==True:
        try:
            saveSettings();
        except:
            print(f"• Exception: {PN}'s settings changes did not save properly. Did you your launching app shut down properly?");
